import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:app_route/app_route.dart';
import 'package:build/build.dart';
import 'package:built_collection/built_collection.dart';
import 'package:collection/collection.dart';
import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';
import 'package:source_gen/source_gen.dart';

class RouteModuleGenerator extends GeneratorForAnnotation<RouteModule> {
  String? basePath;
  List<String> routesRaw = [];
  @override
  generateForAnnotatedElement(
      Element element, ConstantReader annotation, BuildStep buildStep) {
    final name = element.displayName;
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        'Generator cannot target `$name`.',
        todo: 'Remove the [RouteModule] annotation from `$name`.',
        element: element,
      );
    } else if (!element.isAbstract) {
      throw InvalidGenerationSourceError(
        'Generator cannot target `$name`.',
        todo: 'Add abstraction to class `$name`.',
        element: element,
      );
    }

    basePath = annotation.peek('name')?.stringValue;
    final classBuilder = _generateClassImpl(element);

    final emitter = DartEmitter();
    return DartFormatter().format('${classBuilder.accept(emitter)}');
  }

  Class _generateClassImpl(ClassElement element) {
    final className = element.displayName;
    final annotClassConsts = element.constructors
        .where((c) => !c.isFactory && !c.isDefaultConstructor);

    return Class((c) {
      c
        ..docs = ListBuilder([
          '/// Generate ClassImpl for `$className`.',
          '/// ',
          '/// This method is automatically generated by `app_route`.',
        ])
        ..name = className.replaceAll('_', '_\$')
        ..types.addAll(element.typeParameters.map((e) => refer(e.name)));
      if (annotClassConsts.isEmpty) {
        c.constructors.add(_generateConstructor());
        c.implements.add(refer(_generateTypeParameterizedName(element)));
      }
      c.extend = Reference(element.supertype?.toString());
      c.methods.addAll(_parseMethods(element));
      c.methods.add(_generateRoutes());
    });
  }

  Constructor _generateConstructor({ConstructorElement? superClassConst}) =>
      Constructor((c) {
        if (superClassConst != null) {
          var superConstName = 'super';
          if (superClassConst.name.isNotEmpty) {
            superConstName += '.${superClassConst.name}';
            c.name = superClassConst.name;
          }
          final constParams = superClassConst.parameters;
          constParams.forEach((element) {
            if (!element.isOptional || element.isPrivate) {
              c.requiredParameters.add(Parameter((p) => p
                ..type = refer(_displayString(element.type))
                ..name = element.name));
            } else {
              c.optionalParameters.add(Parameter((p) => p
                ..named = element.isNamed
                ..type = refer(_displayString(element.type))
                ..name = element.name));
            }
          });
          final paramList = constParams
              .map((e) => (e.isNamed ? '${e.name}: ' : '') + '${e.name}');
          c.initializers
              .add(Code('$superConstName(' + paramList.join(',') + ')'));
        }
      });

  Iterable<Method> _parseMethods(ClassElement element) => (<MethodElement>[]
            ..addAll(element.methods)
            ..addAll(element.mixins.expand((i) => i.methods)))
          .where((MethodElement m) {
        return m.isAbstract &&
            (m.returnType.isDartAsyncFuture || m.returnType.isDartAsyncStream);
      }).map((m) => _generateMethod(m)!);

  String _generateTypeParameterizedName(TypeParameterizedElement element) =>
      element.displayName +
      (element.typeParameters.isNotEmpty
          ? '<${element.typeParameters.join(',')}>'
          : '');

  Method? _generateMethod(MethodElement m) {
    final targetPage = _getChildPage(m);
    _generateChildRoute(m);

    return Method((mm) {
      mm
        ..returns =
            refer(_displayString(m.type.returnType, withNullability: true))
        ..name = m.displayName
        ..types.addAll(m.typeParameters.map((e) => refer(e.name)))
        ..lambda = true
        ..modifier = m.returnType.isDartAsyncFuture
            ? MethodModifier.async
            : MethodModifier.asyncStar
        ..annotations.add(CodeExpression(Code('override')))
        ..docs = ListBuilder([
          '/// Push screen to `$targetPage`.',
          '/// Target route name `${basePath}${_getPathName(m)}`.'
        ]);

      /// required parameters
      mm.requiredParameters.addAll(m.parameters
          .where((it) => it.isRequiredPositional)
          .map((it) => Parameter((p) => p
            ..name = it.name
            ..named = it.isNamed)));

      /// optional positional or named parameters
      mm.optionalParameters.addAll(m.parameters
          .where((i) => i.isOptional || i.isRequiredNamed)
          .map((it) => Parameter((p) => p
            ..required = (it.isNamed &&
                it.type.nullabilitySuffix == NullabilitySuffix.none &&
                !it.hasDefaultValue)
            ..name = it.name
            ..named = it.isNamed
            ..defaultTo = it.defaultValueCode == null
                ? null
                : Code(it.defaultValueCode!))));
      mm.body = _generateBody(m);
    });
  }

  Method _generateRoutes() {
    final method = Method((mm) {
      mm
        ..returns = refer('List<ModularRoute>')
        ..name = 'routes'
        ..type = MethodType.getter
        ..lambda = true
        ..annotations.add(CodeExpression(Code('override')));
      mm.body = Code("[${routesRaw.join('\n')}]");
    });
    routesRaw.clear();

    return method;
  }

  Code _generateBody(MethodElement m) {
    final pathName = _getPathName(m);
    final targetPath = '${basePath}${pathName}';
    final args = {};
    String arguments = '';
    m.parameters.forEach((params) {
      args["'${_getParamName(params)}'"] = '${params.name}';
    });
    if (args.isNotEmpty) {
      arguments = 'arguments: $args,';
    }
    return Code("Modular.to.pushNamed('$targetPath', $arguments)");
  }

  void _generateChildRoute(MethodElement m) {
    final pathName = _getPathName(m);
    final targetPage = _getChildPage(m);
    final blocs = _getBlocs(m);

    final key = 'Key("${pathName.replaceFirst('/', '')}")';
    String child = 'const $targetPage(key: $key)';
    List<String> args = [];
    m.parameters.forEach((params) {
      final argName = _getParamName(params);
      args.add("$argName: args.data['${argName}'] as ${params.type}");
    });
    if (args.isNotEmpty) {
      child = '$targetPage(key: const $key, ${args.join(',')},)';
    }

    if (blocs.isNotEmpty) {
      if (blocs.length > 1) {
        child = "MultiBlocProvider("
            "providers: [${blocs.map((bloc) => "BlocProvider<$bloc>(create: (_) => $bloc(),)").toList().join(",")},],"
            "child: $child,"
            ")";
      } else {
        child =
            "BlocProvider<${blocs.first}>(create: (_) => ${blocs.first}(), child: $child,)";
      }
    }

    routesRaw.add("ChildRoute('$pathName', child: (_, args) => $child,),");
  }

  String _getChildPage(MethodElement prop) {
    final annot = _typeChecker(ModulePage)
        .firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    final childType = reader.peek('child')!.objectValue.toTypeValue();
    return _getStringType(childType!);
  }

  String _getPathName(MethodElement prop) {
    final annot = _typeChecker(ModulePage)
        .firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    return reader.peek('name')!.stringValue;
  }

  String _getParamName(ParameterElement prop) {
    final annot =
        _typeChecker(Arg).firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    return reader.peek('name')!.stringValue;
  }

  List<String> _getBlocs(MethodElement prop) {
    final annot = _typeChecker(RegisterBlocs)
        .firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    final blocs = reader.peek('blocs')?.listValue;
    if (blocs == null) {
      return [];
    }

    return blocs.map((e) => _getStringType(e.toTypeValue()!)).toList();
  }

  TypeChecker _typeChecker(Type type) => TypeChecker.fromRuntime(type);

  String _getStringType(DartType type) {
    return type.toString().replaceAll("*", "");
  }

  String _displayString(dynamic e, {bool withNullability = false}) {
    try {
      return e.getDisplayString(withNullability: withNullability);
    } catch (error) {
      if (error is TypeError) {
        return e.getDisplayString();
      } else {
        rethrow;
      }
    }
  }
}

class AppRouteGenerator extends GeneratorForAnnotation<AppRoute> {
  @override
  FutureOr<String> generateForAnnotatedElement(
      Element element, ConstantReader annotation, BuildStep buildStep) {
    final name = element.displayName;
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        'Generator cannot target `$name`.',
        todo: 'Remove the [AppRoute] annotation from `$name`.',
        element: element,
      );
    }

    final methodBuilder = _generateChildRoutes(element);

    final emitter = DartEmitter();
    return DartFormatter().format('${methodBuilder.accept(emitter)}');
  }

  Method _generateChildRoutes(ClassElement element) {
    final name = element.displayName;
    final m =
        element.accessors.firstWhereOrNull((i) => i.name == 'childRoutes');
    if (m == null) {
      throw InvalidGenerationSourceError(
        'Generator cannot target `$name`',
        todo:
            'Add getter [static List<ChildRoute> get childRoutes() => _\$${name}Child();] to class `$name`.',
        element: element,
      );
    }

    return Method((mm) {
      mm
        ..docs = ListBuilder([
          '/// Generate child routes for `$name`.',
          '/// ',
          '/// This method is automatically generated by `app_route`.',
        ])
        ..returns =
            refer(_displayString(m.type.returnType, withNullability: true))
        ..name = "_\$${name}Child"
        ..types.addAll(m.typeParameters.map((e) => refer(e.name)))
        ..body = _generateBody(element);
    });
  }

  Code _generateBody(ClassElement el) {
    final className = el.name;
    final childRoutes = el.fields.where((element) => element.isConst).map((i) {
      final constName = i.name;
      final childType = _getChildType(i);
      final args = _getArgs(i);
      final blocs = _getBlocs(i);

      String child = 'const $childType()';
      if (args.isNotEmpty) {
        final parsedArgs = args.join(',\n');
        child = "$childType($parsedArgs)";
      }

      if (blocs.isNotEmpty) {
        if (blocs.length > 1) {
          child = "MultiBlocProvider("
              "providers: [${blocs.map((bloc) => "BlocProvider<$bloc>(create: (_) => $bloc())").toList().join(",")}],"
              "child: $child,"
              ")";
        } else {
          child =
              "BlocProvider<${blocs.first}>(create: (_) => ${blocs.first}(), child: $child,)";
        }
      }

      return "ChildRoute($className.$constName, child: (_, args) => $child,),";
    }).toList();

    el.fields
        .where((element) => element.declaration.isSynthetic)
        .where((element) => !element.declaration.type.isDartCoreList)
        .forEach((element) {
      final name = element.name;
      final retType = element.declaration.type;
      childRoutes.add("ModuleRoute('/$name', module: $retType()),");
    });

    return Block.of([Code("return [${childRoutes.join('\n')}];")]);
  }

  TypeChecker _typeChecker(Type type) => TypeChecker.fromRuntime(type);

  String _getChildType(FieldElement prop) {
    final annot = _typeChecker(AppRoutePage)
        .firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    final childType = reader.peek('child')!.objectValue.toTypeValue();
    return _getStringType(childType!);
  }

  List<String> _getBlocs(FieldElement prop) {
    final annot = _typeChecker(RegisterBlocs)
        .firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    final blocs = reader.peek('blocs')?.listValue;
    if (blocs == null) {
      return [];
    }

    return blocs.map((e) => _getStringType(e.toTypeValue()!)).toList();
  }

  List<String> _getArgs(FieldElement prop) {
    final annot = _typeChecker(AppRoutePage)
        .firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    final args = reader.peek('args')?.objectValue;
    if (args == null || args.isNull) {
      return [];
    }

    bool isData = _typeChecker(ArgData).isAssignableFromType(args.type!);

    return args
            .getField("keys")
            ?.toListValue()
            ?.map((e) => e.toStringValue())
            .map((name) {
          if (isData) {
            return "$name: args.data[\"$name\"]";
          }
          return "$name: args.params[\"$name\"]";
        }).toList() ??
        [];
  }

  String _getStringType(DartType type) {
    return type.toString().replaceAll("*", "");
  }

  String _displayString(dynamic e, {bool withNullability = false}) {
    try {
      return e.getDisplayString(withNullability: withNullability);
    } catch (error) {
      if (error is TypeError) {
        return e.getDisplayString();
      } else {
        rethrow;
      }
    }
  }
}

extension DartTypeStreamAnnotation on DartType {
  bool get isDartAsyncStream {
    final element = this.element == null ? null : this.element as ClassElement;
    if (element == null) {
      return false;
    }
    return element.name == "Stream" && element.library.isDartAsync;
  }
}
