import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:app_route/app_route.dart';
import 'package:build/build.dart';
import 'package:built_collection/built_collection.dart';
import 'package:collection/collection.dart';
import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';
import 'package:source_gen/source_gen.dart';

class AppRouteGenerator extends GeneratorForAnnotation<AppRoute> {
  @override
  FutureOr<String> generateForAnnotatedElement(
      Element element, ConstantReader annotation, BuildStep buildStep) {
    final name = element.displayName;
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        'Generator cannot target `$name`.',
        todo: 'Remove the [AppRoute] annotation from `$name`.',
      );
    } else if (!element.isAbstract) {
      throw InvalidGenerationSourceError(
        'Generator cannot target `$name`.',
        todo: 'Please change the `$name` to abstract class.',
      );
    }

    final methodBuilder = _generateChildRoutes(element);

    final emitter = DartEmitter();
    return DartFormatter().format('${methodBuilder.accept(emitter)}');
  }

  Method _generateChildRoutes(ClassElement element) {
    final name = element.displayName;
    final m =
        element.accessors.firstWhereOrNull((i) => i.name == 'childRoutes');
    if (m == null) {
      throw InvalidGenerationSourceError(
        'Generator cannot target `$name`',
        todo:
            'Add getter [static List<ChildRoute> get childRoutes() => _\$${name}Child();] to class `$name`.',
      );
    }

    return Method((mm) {
      mm
        ..docs = ListBuilder([
          '/// Generate child routes for `$name`.',
          '/// ',
          '/// This method is automatically generated by `app_route`.',
        ])
        ..returns =
            refer(_displayString(m.type.returnType, withNullability: true))
        ..name = "_\$${name}Child"
        ..types.addAll(m.typeParameters.map((e) => refer(e.name)))
        ..body = _generateBody(element);
    });
  }

  Code _generateBody(ClassElement el) {
    final className = el.name;
    final childRoutes = el.fields
        .where((element) => element.isConst)
        .map((i) {
          final routeName = i.name;
          final childType = _getChildType(i);
          final args = _getArgs(i);
          final blocs = _getBlocs(i);

          String child = 'const $childType()';
          if (args.isNotEmpty) {
            final parsedArgs = args.join(',\n');
            child = "$childType($parsedArgs)";
          }

          if (blocs.isNotEmpty) {
            if (blocs.length > 1) {
              child = "MultiBlocProvider("
                  "providers: [${blocs.map((bloc) => "BlocProvider<$bloc>(create: (_) => $bloc())").toList().join(",")}],"
                  "child: $child,"
                  ")";
            } else {
              child =
                  "BlocProvider<${blocs.first}>(create: (_) => ${blocs.first}(), child: $child,)";
            }
          }

          return "ChildRoute($className.$routeName, child: (_, args) => $child,),";
        })
        .toList()
        .join('\n');

    return Block.of([Code("return [$childRoutes];")]);
  }

  TypeChecker _typeChecker(Type type) => TypeChecker.fromRuntime(type);

  String _getChildType(FieldElement prop) {
    final annot = _typeChecker(AppRoutePage)
        .firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    final childType = reader.peek('child')!.objectValue.toTypeValue();
    return _getStringType(childType!);
  }

  List<String> _getBlocs(FieldElement prop) {
    final annot = _typeChecker(RegisterBlocs)
        .firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    final blocs = reader.peek('blocs')?.listValue;
    if (blocs == null) {
      return [];
    }

    return blocs.map((e) => _getStringType(e.toTypeValue()!)).toList();
  }

  List<String> _getArgs(FieldElement prop) {
    final annot = _typeChecker(AppRoutePage)
        .firstAnnotationOf(prop, throwOnUnresolved: false);
    final reader = ConstantReader(annot);
    final args = reader.peek('args')?.objectValue;
    if (args == null || args.isNull) {
      return [];
    }

    bool isData = _typeChecker(ArgData).isAssignableFromType(args.type!);

    return args
            .getField("keys")
            ?.toListValue()
            ?.map((e) => e.toStringValue())
            .map((name) {
          if (isData) {
            return "$name: args.data[\"$name\"]";
          }
          return "$name: args.params[\"$name\"]";
        }).toList() ??
        [];
  }

  String _getStringType(DartType type) {
    return type.toString().replaceAll("*", "");
  }

  String _displayString(dynamic e, {bool withNullability = false}) {
    try {
      return e.getDisplayString(withNullability: withNullability);
    } catch (error) {
      if (error is TypeError) {
        return e.getDisplayString();
      } else {
        rethrow;
      }
    }
  }
}
